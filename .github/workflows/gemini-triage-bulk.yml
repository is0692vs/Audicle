name: "ğŸ“‹ Gemini Bulk Triage"

on:
    workflow_call:
        inputs:
            issues_to_triage:
                type: "string"
                description: "JSON array of issues to triage"
                required: true
            additional_context:
                type: "string"
                description: "Any additional context from the request"
                required: false
            language:
                type: "string"
                description: "Response language (default: 'ja' â€” JP)."
                default: "ja"
            gemini_model:
                type: "string"
                description: "Gemini model override"
                required: false
                default: ""
        secrets:
          GEMINI_API_KEY:
            required: true

defaults:
    run:
        shell: "bash"

jobs:
    triage_bulk:
        runs-on: "ubuntu-latest"
        permissions:
          contents: "read"
          issues: "read"
          pull-requests: "read"
        outputs:
            available_labels: "${{ steps.get_labels.outputs.available_labels }}"
            triaged_issues: "${{ steps.collect_outputs.outputs.triaged_issues }}"
        steps:
            - name: "Get repository labels"
              id: "get_labels"
              uses: "actions/github-script@v7"
              with:
                  script: |-
                      const { data: labels } = await github.rest.issues.listLabelsForRepo({
                        owner: context.repo.owner,
                        repo: context.repo.repo,
                      });

                      if (!labels || labels.length === 0) {
                        core.setFailed('There are no issue labels in this repository.')
                      }

                      const labelNames = labels.map(label => label.name).sort();
                      core.setOutput('available_labels', labelNames.join(','));
                      core.info(`Found ${labelNames.length} labels: ${labelNames.join(', ')}`);
                      return labelNames;

            - name: "Run Gemini Issue Analysis (bulk)"
              id: "gemini_issue_analysis"
              uses: "google-github-actions/run-gemini-cli@v0" # ratchet:exclude
              env:
                  GITHUB_TOKEN: "${{ github.token }}"
                  ISSUES_TO_TRIAGE: "${{ inputs.issues_to_triage }}"
                  REPOSITORY: "${{ github.repository }}"
                  AVAILABLE_LABELS: "${{ steps.get_labels.outputs.available_labels }}"
                  GEMINI_API_KEY: "${{ secrets.GEMINI_API_KEY }}"
              with:
                  # No GCP fields - using API key only
                  gemini_api_key: "${{ secrets.GEMINI_API_KEY }}"
                  gemini_model: "${{ inputs.gemini_model || vars.GEMINI_MODEL || '' }}"
                  settings: |-
                      {
                        "model": {
                          "maxSessionTurns": 25
                        },
                        "telemetry": {
                          "enabled": false
                        },
                        "tools": {
                          "core": [
                            "run_shell_command"
                          ]
                        }
                      }
                  prompt: |-
                      å‡ºåŠ›ã¯å¿…ãšæ—¥æœ¬èªã§è¡Œã£ã¦ãã ã•ã„ã€‚
                      å¿œç­”è¨€èª: ${{ inputs.language }}
                      ## Role
                      You are a highly efficient Issue Triage Engineer. Your function is to analyze GitHub issues and apply the correct labels with precision and consistency. You operate autonomously and produce only the specified JSON output. Your task is to triage and label a list of GitHub issues.

                      ## Primary Directive

                      You will retrieve issue data and available labels from environment variables, analyze the issues, and assign the most relevant labels. You will then generate a single JSON array containing your triage decisions and write it to /tmp/triaged_issues.json.

                      JSONãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆã™ã‚‹éš›ã¯ï¼Œã‚¨ã‚¹ã‚±ãƒ¼ãƒ—å•é¡Œã‚’é¿ã‘ã‚‹ãŸã‚ï¼Œå¿…ãšPythonãƒ¯ãƒ³ãƒ©ã‚¤ãƒŠãƒ¼ã‚’ä½¿ç”¨ã™ã‚‹ã“ã¨ã€‚
                      Execute exactly this format:
                      run_shell_command(python3 -c "import json; f=open('/tmp/triaged_issues.json', 'w'); json.dump([{'issue_number': 123, 'labels_to_set': ['bug']}], f); f.close()")

                      ## STRICT OUTPUT RULES
                      1. You MUST NOT output the JSON content in your text response.
                      2. You MUST NOT output any conversational text (e.g., "Here is the JSON...").
                      3. You MUST ONLY use the `run_shell_command` tool to write the file.
                      4. If you do not execute the tool, the workflow will fail.

                      Execute the Python script now.

            - name: "Collect outputs"
              id: "collect_outputs"
              uses: "actions/github-script@v7"
              with:
                  script: |-
                      const fs = require('fs');
                      const path = '/tmp/triaged_issues.json';
                      let triagedIssues = '[]';
                      
                      try {
                        if (fs.existsSync(path)) {
                          const content = fs.readFileSync(path, 'utf8');
                          console.log('File content preview:', content.substring(0, 100)); // ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚‚å‡ºã™
                          // Validate JSON
                          JSON.parse(content);
                          triagedIssues = content;
                        } else {
                          core.warning('âš ï¸ Output file /tmp/triaged_issues.json was NOT found. Gemini likely failed to execute the write command.');
                        }
                      } catch (error) {
                        core.warning(`Error reading or parsing triaged issues file: ${error.message}`);
                      }
                      
                      core.setOutput('triaged_issues', triagedIssues);
